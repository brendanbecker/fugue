{
  "bug_id": "BUG-044",
  "title": "MCP bridge process hangs indefinitely, stops reading stdin",
  "component": "mcp-bridge",
  "severity": "high",
  "priority": "P1",
  "status": "new",
  "reported_date": "2026-01-16",
  "updated_date": "2026-01-16",
  "assigned_to": null,
  "tags": ["mcp", "claude-code", "hang", "stdin", "async", "tokio", "deadlock"],
  "affected_versions": [],
  "environment": "Linux (WSL2) - Claude Code MCP integration",
  "reproducibility": "sometimes",
  "description": "The mcp-bridge process can enter a state where it stops reading from stdin entirely, causing all MCP tool calls to hang indefinitely. The 25-second daemon response timeout does not trigger. Killing the hung process and letting Claude Code spawn a fresh one resolves the issue.",
  "steps_to_reproduce": [
    "Configure ccmux MCP server in Claude Code settings",
    "Start ccmux daemon (ccmux-server start)",
    "Use Claude Code to invoke MCP tools repeatedly",
    "Eventually mcp-bridge enters hung state",
    "Observe MCP tool calls hang for 4.5+ minutes with no timeout",
    "Check socket state with: ss -x | grep $(pgrep -f mcp-bridge)",
    "Check thread syscalls with: for t in /proc/$(pgrep -f mcp-bridge)/task/*; do echo \"Thread $(basename $t): $(cat $t/syscall | cut -d' ' -f1)\"; done"
  ],
  "expected_behavior": "MCP bridge should continuously read from stdin and process requests. The 25-second daemon response timeout should trigger if processing stalls. No MCP call should hang longer than timeout + grace period.",
  "actual_behavior": "MCP tool calls hang for 4.5+ minutes (tested) without any timeout. Socket analysis shows stdin (fd0) has 1323+ bytes queued but not being read. Claude Code is blocked trying to send more data (6912 bytes in send queue). Process is sleeping on futex (syscall 202), not blocked on I/O. All 13 threads are on futex except one on epoll_wait.",
  "evidence": {
    "socket_state": {
      "description": "Socket state showing data stuck in queues",
      "stdin": "u_str ESTAB 1323 0 * 34100 (stdin) * 34101",
      "stdout": "clear, no backpressure",
      "daemon": "established and clear (0 bytes queued)"
    },
    "thread_syscalls": {
      "description": "All threads waiting on futex",
      "thread_6696": "202 (futex)",
      "thread_6699": "232 (epoll_wait)",
      "threads_6700_to_6709": "202 (futex)"
    },
    "timing": "Hung for 4.5+ minutes with no timeout trigger",
    "logs": "No error messages in mcp-bridge.log after initial connection"
  },
  "root_cause": "Multiple hypotheses: (1) Async/sync mixing issue - main loop uses synchronous stdin.lock().lines() inside async function, iterator may enter bad state during handle_request().await. (2) Deadlock in ConnectionManager - complex state with multiple channels (daemon_tx, state_tx, state_rx) and RwLocks may deadlock between health monitor and request handling. (3) Tokio runtime starvation - task not yielding properly. (4) Response handling infinite loop - recv_filtered may not time out correctly under certain message patterns.",
  "impact": "MCP tools become completely unusable until mcp-bridge is killed. User must manually identify and kill the process. Breaks the primary use case of AI-assisted terminal management through Claude Code."
}
